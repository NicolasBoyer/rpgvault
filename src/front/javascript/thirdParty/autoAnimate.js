/**
 * Minified by jsDelivr using Terser v5.14.1.
 * Original file: /npm/@formkit/auto-animate@1.0.0-beta.3/index.mjs
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
const parents = new Set(); const coords = new WeakMap(); const siblings = new WeakMap(); const animations = new WeakMap(); const intersections = new WeakMap(); const intervals = new WeakMap(); const options = new WeakMap(); const debounces = new WeakMap(); const enabled = new WeakSet(); let root; const TGT = '__aa_tgt'; const DEL = '__aa_del'; const handleMutations = e => { const t = getElements(e); t && t.forEach(e => animate(e)) }; const handleResizes = e => { e.forEach(e => { e.target === root && updateAllPos(), coords.has(e.target) && updatePos(e.target) }) }; function observePosition (e) { const t = intersections.get(e); t == null || t.disconnect(); let n = coords.get(e); let o = 0; n || (n = getCoords(e), coords.set(e, n)); const { offsetWidth: i, offsetHeight: a } = root; const s = [n.top - 5, i - (n.left + 5 + n.width), a - (n.top + 5 + n.height), n.left - 5].map(e => -1 * Math.floor(e) + 'px').join(' '); const r = new IntersectionObserver(() => { ++o > 1 && updatePos(e) }, { root: root, threshold: 1, rootMargin: s }); r.observe(e), intersections.set(e, r) } function updatePos (e) { clearTimeout(debounces.get(e)); const t = getOptions(e); const n = typeof t === 'function' ? 500 : t.duration; debounces.set(e, setTimeout(async () => { const t = animations.get(e); t && !await t.finished || (coords.set(e, getCoords(e)), observePosition(e)) }, n)) } function updateAllPos () { clearTimeout(debounces.get(root)), debounces.set(root, setTimeout(() => { parents.forEach(e => forEach(e, e => lowPriority(() => updatePos(e)))) }, 100)) } function poll (e) { setTimeout(() => { intervals.set(e, setInterval(() => lowPriority(updatePos.bind(null, e)), 2e3)) }, Math.round(2e3 * Math.random())) } function lowPriority (e) { typeof requestIdleCallback === 'function' ? requestIdleCallback(() => e()) : requestAnimationFrame(() => e()) } let mutations, resize; function getElements (e) { return e.reduce((e, t) => { if (!1 === e) return !1; if (t.target instanceof Element) { if (target(t.target), !e.has(t.target)) { e.add(t.target); for (let n = 0; n < t.target.children.length; n++) { const o = t.target.children.item(n); if (o) { if (DEL in o) return !1; target(t.target, o), e.add(o) } } } if (t.removedNodes.length) for (let n = 0; n < t.removedNodes.length; n++) { const o = t.removedNodes[n]; if (DEL in o) return !1; o instanceof Element && (e.add(o), target(t.target, o), siblings.set(o, [t.previousSibling, t.nextSibling])) } } return e }, new Set()) } function target (e, t) { t || TGT in e ? t && !(TGT in t) && Object.defineProperty(t, TGT, { value: e }) : Object.defineProperty(e, TGT, { value: e }) } function animate (e) { var t; const n = root.contains(e); const o = coords.has(e); n && siblings.has(e) && siblings.delete(e), animations.has(e) && ((t = animations.get(e)) === null || void 0 === t || t.cancel()), o && n ? remain(e) : o && !n ? remove(e) : add(e) } function raw (e) { return Number(e.replace(/[^0-9.\-]/g, '')) } function getCoords (e) { const t = e.getBoundingClientRect(); return { top: t.top + window.scrollY, left: t.left + window.scrollX, width: t.width, height: t.height } } function getTransitionSizes (e, t, n) { let o = t.width; let i = t.height; let a = n.width; let s = n.height; const r = getComputedStyle(e); if (r.getPropertyValue('box-sizing') === 'content-box') { const e = raw(r.paddingTop) + raw(r.paddingBottom) + raw(r.borderTopWidth) + raw(r.borderBottomWidth); const t = raw(r.paddingLeft) + raw(r.paddingRight) + raw(r.borderRightWidth) + raw(r.borderLeftWidth); o -= t, a -= t, i -= e, s -= e } return [o, a, i, s].map(Math.round) } function getOptions (e) { return TGT in e && options.has(e[TGT]) ? options.get(e[TGT]) : { duration: 250, easing: 'ease-in-out' } } function getTarget (e) { if (TGT in e) return e[TGT] } function isEnabled (e) { const t = getTarget(e); return !!t && enabled.has(t) } function forEach (e, ...t) { t.forEach(t => t(e, options.has(e))); for (let n = 0; n < e.children.length; n++) { const o = e.children.item(n); o && t.forEach(e => e(o, options.has(o))) } } function remain (e) { const t = coords.get(e); const n = getCoords(e); if (!isEnabled(e)) return coords.set(e, n); let o; if (!t) return; const i = getOptions(e); if (typeof i !== 'function') { const a = t.left - n.left; const s = t.top - n.top; const [r, d, l, c] = getTransitionSizes(e, t, n); const u = { transform: `translate(${a}px, ${s}px)` }; const p = { transform: 'translate(0, 0)' }; r !== d && (u.width = `${r}px`, p.width = `${d}px`), l !== c && (u.height = `${l}px`, p.height = `${c}px`), o = e.animate([u, p], { duration: i.duration, easing: i.easing }) } else o = new Animation(i(e, 'remain', t, n)), o.play(); animations.set(e, o), coords.set(e, n), o.addEventListener('finish', updatePos.bind(null, e)) } function add (e) { const t = getCoords(e); coords.set(e, t); const n = getOptions(e); if (!isEnabled(e)) return; let o; typeof n !== 'function' ? o = e.animate([{ transform: 'scale(.98)', opacity: 0 }, { transform: 'scale(0.98)', opacity: 0, offset: 0.5 }, { transform: 'scale(1)', opacity: 1 }], { duration: 1.5 * n.duration, easing: 'ease-in' }) : (o = new Animation(n(e, 'add', t)), o.play()), animations.set(e, o), o.addEventListener('finish', updatePos.bind(null, e)) } function remove (e) { var t; if (!siblings.has(e) || !coords.has(e)) return; const [n, o] = siblings.get(e); function i () { var t; e.remove(), coords.delete(e), siblings.delete(e), animations.delete(e), (t = intersections.get(e)) === null || void 0 === t || t.disconnect() } if (Object.defineProperty(e, DEL, { value: !0 }), o && o.parentNode && o.parentNode instanceof Element ? o.parentNode.insertBefore(e, o) : n && n.parentNode ? n.parentNode.appendChild(e) : (t = getTarget(e)) === null || void 0 === t || t.appendChild(e), !isEnabled(e)) return i(); const [a, s, r, d] = deletePosition(e); const l = getOptions(e); const c = coords.get(e); let u; Object.assign(e.style, { position: 'absolute', top: `${a}px`, left: `${s}px`, width: `${r}px`, height: `${d}px`, margin: 0, pointerEvents: 'none', transformOrigin: 'center', zIndex: 100 }), typeof l !== 'function' ? u = e.animate([{ transform: 'scale(1)', opacity: 1 }, { transform: 'scale(.98)', opacity: 0 }], { duration: l.duration, easing: 'ease-out' }) : (u = new Animation(l(e, 'remove', c)), u.play()), animations.set(e, u), u.addEventListener('finish', i) } function deletePosition (e) { const t = coords.get(e); const [n,, o] = getTransitionSizes(e, t, getCoords(e)); let i = e.parentElement; for (;i && (getComputedStyle(i).position === 'static' || i instanceof HTMLBodyElement);)i = i.parentElement; i || (i = document.body); const a = getComputedStyle(i); const s = coords.get(i) || getCoords(i); return [Math.round(t.top - s.top) - raw(a.borderTopWidth), Math.round(t.left - s.left) - raw(a.borderLeftWidth), n, o] } function autoAnimate (e, t = {}) { if (mutations && resize) { window.matchMedia('(prefers-reduced-motion: reduce)').matches && typeof t !== 'function' && !t.disrespectUserMotionPreference || (enabled.add(e), getComputedStyle(e).position === 'static' && Object.assign(e.style, { position: 'relative' }), forEach(e, updatePos, poll, e => resize == null ? void 0 : resize.observe(e)), typeof t === 'function' ? options.set(e, t) : options.set(e, { duration: 250, easing: 'ease-in-out', ...t }), mutations.observe(e, { childList: !0 }), parents.add(e)) } return Object.freeze({ parent: e, enable: () => { enabled.add(e) }, disable: () => { enabled.delete(e) }, isEnabled: () => enabled.has(e) }) } typeof window !== 'undefined' && (root = document.documentElement, mutations = new MutationObserver(handleMutations), resize = new ResizeObserver(handleResizes), resize.observe(root)); const vAutoAnimate = { mounted: (e, t) => { autoAnimate(e, t.value || {}) } }; export { autoAnimate as default, getTransitionSizes, vAutoAnimate }
// # sourceMappingURL=/sm/ca0152a5e481807c0eab739fa51b4dc188c051104cbc9dec50eb89c8036aaf62.map
