/**
 * Skipped minification because the original files appears to be already minified.
 * Original file: /npm/lit-html@2.3.1/lit-html.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var t; const i = window; const s = i.trustedTypes; const e = s ? s.createPolicy('lit-html', { createHTML: t => t }) : void 0; const o = `lit$${(Math.random() + '').slice(9)}$`; const n = '?' + o; const l = `<${n}>`; const h = document; const r = (t = '') => h.createComment(t); const d = t => t === null || typeof t !== 'object' && typeof t !== 'function'; const u = Array.isArray; const c = t => u(t) || typeof (t == null ? void 0 : t[Symbol.iterator]) === 'function'; const v = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g; const a = /-->/g; const f = />/g; const _ = RegExp(">|[ \t\n\f\r](?:([^\\s\"'>=/]+)([ \t\n\f\r]*=[ \t\n\f\r]*(?:[^ \t\n\f\r\"'`<>=]|(\"|')|))|$)", 'g'); const m = /'/g; const p = /"/g; const $ = /^(?:script|style|textarea|title)$/i; const g = t => (i, ...s) => ({ _$litType$: t, strings: i, values: s }); const y = g(1); const w = g(2); const x = Symbol.for('lit-noChange'); const b = Symbol.for('lit-nothing'); const T = new WeakMap(); const A = (t, i, s) => { var e, o; const n = (e = s == null ? void 0 : s.renderBefore) !== null && void 0 !== e ? e : i; let l = n._$litPart$; if (void 0 === l) { const t = (o = s == null ? void 0 : s.renderBefore) !== null && void 0 !== o ? o : null; n._$litPart$ = l = new S(i.insertBefore(r(), t), t, void 0, s != null ? s : {}) } return l._$AI(t), l }; const E = h.createTreeWalker(h, 129, null, !1); const C = (t, i) => { const s = t.length - 1; const n = []; let h; let r = i === 2 ? '<svg>' : ''; let d = v; for (let i = 0; i < s; i++) { const s = t[i]; let e; let u; let c = -1; let g = 0; for (;g < s.length && (d.lastIndex = g, u = d.exec(s), u !== null);)g = d.lastIndex, d === v ? u[1] === '!--' ? d = a : void 0 !== u[1] ? d = f : void 0 !== u[2] ? ($.test(u[2]) && (h = RegExp('</' + u[2], 'g')), d = _) : void 0 !== u[3] && (d = _) : d === _ ? u[0] === '>' ? (d = h != null ? h : v, c = -1) : void 0 === u[1] ? c = -2 : (c = d.lastIndex - u[2].length, e = u[1], d = void 0 === u[3] ? _ : u[3] === '"' ? p : m) : d === p || d === m ? d = _ : d === a || d === f ? d = v : (d = _, h = void 0); const y = d === _ && t[i + 1].startsWith('/>') ? ' ' : ''; r += d === v ? s + l : c >= 0 ? (n.push(e), s.slice(0, c) + '$lit$' + s.slice(c) + o + y) : s + o + (c === -2 ? (n.push(void 0), i) : y) } const u = r + (t[s] || '<?>') + (i === 2 ? '</svg>' : ''); if (!Array.isArray(t) || !t.hasOwnProperty('raw')) throw Error('invalid template strings array'); return [void 0 !== e ? e.createHTML(u) : u, n] }; class P {constructor ({ strings: t, _$litType$: i }, e) { let l; this.parts = []; let h = 0; let d = 0; const u = t.length - 1; const c = this.parts; const [v, a] = C(t, i); if (this.el = P.createElement(v, e), E.currentNode = this.el.content, i === 2) { const t = this.el.content; const i = t.firstChild; i.remove(), t.append(...i.childNodes) } for (;(l = E.nextNode()) !== null && c.length < u;) { if (l.nodeType === 1) { if (l.hasAttributes()) { const t = []; for (const i of l.getAttributeNames()) if (i.endsWith('$lit$') || i.startsWith(o)) { const s = a[d++]; if (t.push(i), void 0 !== s) { const t = l.getAttribute(s.toLowerCase() + '$lit$').split(o); const i = /([.?@])?(.*)/.exec(s); c.push({ type: 1, index: h, name: i[2], strings: t, ctor: i[1] === '.' ? R : i[1] === '?' ? H : i[1] === '@' ? I : M }) } else c.push({ type: 6, index: h }) } for (const i of t)l.removeAttribute(i) } if ($.test(l.tagName)) { const t = l.textContent.split(o); const i = t.length - 1; if (i > 0) { l.textContent = s ? s.emptyScript : ''; for (let s = 0; s < i; s++)l.append(t[s], r()), E.nextNode(), c.push({ type: 2, index: ++h }); l.append(t[i], r()) } } } else if (l.nodeType === 8) if (l.data === n)c.push({ type: 2, index: h }); else { let t = -1; for (;(t = l.data.indexOf(o, t + 1)) !== -1;)c.push({ type: 7, index: h }), t += o.length - 1 }h++ } } static createElement (t, i) { const s = h.createElement('template'); return s.innerHTML = t, s }} function V (t, i, s = t, e) { var o, n, l, h; if (i === x) return i; let r = void 0 !== e ? (o = s._$Cl) === null || void 0 === o ? void 0 : o[e] : s._$Cu; const u = d(i) ? void 0 : i._$litDirective$; return (r == null ? void 0 : r.constructor) !== u && ((n = r == null ? void 0 : r._$AO) === null || void 0 === n || n.call(r, !1), void 0 === u ? r = void 0 : (r = new u(t), r._$AT(t, s, e)), void 0 !== e ? ((l = (h = s)._$Cl) !== null && void 0 !== l ? l : h._$Cl = [])[e] = r : s._$Cu = r), void 0 !== r && (i = V(t, r._$AS(t, i.values), r, e)), i } class N {constructor (t, i) { this.v = [], this._$AN = void 0, this._$AD = t, this._$AM = i } get parentNode () { return this._$AM.parentNode } get _$AU () { return this._$AM._$AU }p (t) { var i; const { el: { content: s }, parts: e } = this._$AD; const o = ((i = t == null ? void 0 : t.creationScope) !== null && void 0 !== i ? i : h).importNode(s, !0); E.currentNode = o; let n = E.nextNode(); let l = 0; let r = 0; let d = e[0]; for (;void 0 !== d;) { if (l === d.index) { let i; d.type === 2 ? i = new S(n, n.nextSibling, this, t) : d.type === 1 ? i = new d.ctor(n, d.name, d.strings, this, t) : d.type === 6 && (i = new L(n, this, t)), this.v.push(i), d = e[++r] }l !== (d == null ? void 0 : d.index) && (n = E.nextNode(), l++) } return o }m (t) { let i = 0; for (const s of this.v) void 0 !== s && (void 0 !== s.strings ? (s._$AI(t, s, i), i += s.strings.length - 2) : s._$AI(t[i])), i++ }} class S {constructor (t, i, s, e) { var o; this.type = 2, this._$AH = b, this._$AN = void 0, this._$AA = t, this._$AB = i, this._$AM = s, this.options = e, this._$C_ = (o = e == null ? void 0 : e.isConnected) === null || void 0 === o || o } get _$AU () { var t, i; return (i = (t = this._$AM) === null || void 0 === t ? void 0 : t._$AU) !== null && void 0 !== i ? i : this._$C_ } get parentNode () { let t = this._$AA.parentNode; const i = this._$AM; return void 0 !== i && t.nodeType === 11 && (t = i.parentNode), t } get startNode () { return this._$AA } get endNode () { return this._$AB }_$AI (t, i = this) { t = V(this, t, i), d(t) ? t === b || t == null || t === '' ? (this._$AH !== b && this._$AR(), this._$AH = b) : t !== this._$AH && t !== x && this.$(t) : void 0 !== t._$litType$ ? this.T(t) : void 0 !== t.nodeType ? this.k(t) : c(t) ? this.O(t) : this.$(t) }S (t, i = this._$AB) { return this._$AA.parentNode.insertBefore(t, i) }k (t) { this._$AH !== t && (this._$AR(), this._$AH = this.S(t)) }$ (t) { this._$AH !== b && d(this._$AH) ? this._$AA.nextSibling.data = t : this.k(h.createTextNode(t)), this._$AH = t }T (t) { var i; const { values: s, _$litType$: e } = t; const o = typeof e === 'number' ? this._$AC(t) : (void 0 === e.el && (e.el = P.createElement(e.h, this.options)), e); if (((i = this._$AH) === null || void 0 === i ? void 0 : i._$AD) === o) this._$AH.m(s); else { const t = new N(o, this); const i = t.p(this.options); t.m(s), this.k(i), this._$AH = t } }_$AC (t) { let i = T.get(t.strings); return void 0 === i && T.set(t.strings, i = new P(t)), i }O (t) { u(this._$AH) || (this._$AH = [], this._$AR()); const i = this._$AH; let s; let e = 0; for (const o of t)e === i.length ? i.push(s = new S(this.S(r()), this.S(r()), this, this.options)) : s = i[e], s._$AI(o), e++; e < i.length && (this._$AR(s && s._$AB.nextSibling, e), i.length = e) }_$AR (t = this._$AA.nextSibling, i) { var s; for ((s = this._$AP) === null || void 0 === s || s.call(this, !1, !0, i); t && t !== this._$AB;) { const i = t.nextSibling; t.remove(), t = i } }setConnected (t) { var i; void 0 === this._$AM && (this._$C_ = t, (i = this._$AP) === null || void 0 === i || i.call(this, t)) }} class M {constructor (t, i, s, e, o) { this.type = 1, this._$AH = b, this._$AN = void 0, this.element = t, this.name = i, this._$AM = e, this.options = o, s.length > 2 || s[0] !== '' || s[1] !== '' ? (this._$AH = Array(s.length - 1).fill(new String()), this.strings = s) : this._$AH = b } get tagName () { return this.element.tagName } get _$AU () { return this._$AM._$AU }_$AI (t, i = this, s, e) { const o = this.strings; let n = !1; if (void 0 === o)t = V(this, t, i, 0), n = !d(t) || t !== this._$AH && t !== x, n && (this._$AH = t); else { const e = t; let l, h; for (t = o[0], l = 0; l < o.length - 1; l++)h = V(this, e[s + l], i, l), h === x && (h = this._$AH[l]), n || (n = !d(h) || h !== this._$AH[l]), h === b ? t = b : t !== b && (t += (h != null ? h : '') + o[l + 1]), this._$AH[l] = h }n && !e && this.P(t) }P (t) { t === b ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t != null ? t : '') }} class R extends M {constructor () { super(...arguments), this.type = 3 }P (t) { this.element[this.name] = t === b ? void 0 : t }} const k = s ? s.emptyScript : ''; class H extends M {constructor () { super(...arguments), this.type = 4 }P (t) { t && t !== b ? this.element.setAttribute(this.name, k) : this.element.removeAttribute(this.name) }} class I extends M {constructor (t, i, s, e, o) { super(t, i, s, e, o), this.type = 5 }_$AI (t, i = this) { var s; if ((t = (s = V(this, t, i, 0)) !== null && void 0 !== s ? s : b) === x) return; const e = this._$AH; const o = t === b && e !== b || t.capture !== e.capture || t.once !== e.once || t.passive !== e.passive; const n = t !== b && (e === b || o); o && this.element.removeEventListener(this.name, this, e), n && this.element.addEventListener(this.name, this, t), this._$AH = t }handleEvent (t) { var i, s; typeof this._$AH === 'function' ? this._$AH.call((s = (i = this.options) === null || void 0 === i ? void 0 : i.host) !== null && void 0 !== s ? s : this.element, t) : this._$AH.handleEvent(t) }} class L {constructor (t, i, s) { this.element = t, this.type = 6, this._$AN = void 0, this._$AM = i, this.options = s } get _$AU () { return this._$AM._$AU }_$AI (t) { V(this, t) }} const z = { A: '$lit$', M: o, C: n, L: 1, R: C, D: N, V: c, I: V, H: S, N: M, U: H, B: I, F: R, W: L }; const Z = i.litHtmlPolyfillSupport; Z == null || Z(P, S), ((t = i.litHtmlVersions) !== null && void 0 !== t ? t : i.litHtmlVersions = []).push('2.3.1'); export { z as _$LH, y as html, x as noChange, b as nothing, A as render, w as svg }
// # sourceMappingURL=lit-html.js.map
